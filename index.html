<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1"
    />
    <title>Sudoku</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #171a21;
        --panel-2: #1c2028;
        --text: #e8eaf0;
        --muted: #aab1c3;
        --accent: #4c9aff;
        --accent-2: #24caa1;
        --danger: #ff6b6b;
        --warn: #f8c24e;
        --grid: #394356;
        --grid-strong: #e8eaf0;
        --given: #2a3140;
        --select: #2b3a55;
        --highlight: #21314b;
        --same: #2b3d61;
        --conflict: #4b2232;
        --wrong: #4b2232;
        --success: #2e7d32;
        --btn: #232839;
        --btn-hover: #2c3350;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        --radius: 14px;
        --radius-sm: 10px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: radial-gradient(1200px 800px at 20% 0%, #111423, #0b0d13),
          var(--bg);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI,
          Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      .app {
        max-width: 980px;
        margin: 24px auto;
        padding: 16px;
      }

      .topbar {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .logo {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        background: linear-gradient(135deg, var(--accent), #67b8ff);
        display: grid;
        place-items: center;
        color: #0a0e16;
        font-weight: 900;
        box-shadow: var(--shadow);
      }

      .title {
        font-size: 20px;
        font-weight: 800;
        letter-spacing: 0.3px;
      }

      .center {
        display: flex;
        justify-content: center;
        gap: 8px;
        align-items: center;
      }

      .right {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        align-items: center;
      }

      .pill {
        background: var(--panel);
        border: 1px solid #262c3b;
        border-radius: 999px;
        padding: 6px 12px;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .select {
        background: var(--panel);
        color: var(--text);
        border: 1px solid #262c3b;
        padding: 8px 10px;
        border-radius: var(--radius-sm);
        outline: none;
      }

      button {
        appearance: none;
        border: none;
        background: var(--btn);
        color: var(--text);
        padding: 10px 14px;
        border-radius: var(--radius-sm);
        cursor: pointer;
        transition: transform 0.05s ease, background 0.15s ease, opacity
          0.15s ease;
        border: 1px solid #2d3345;
      }

      button:hover {
        background: var(--btn-hover);
      }

      button:active {
        transform: translateY(1px);
      }

      .btn-primary {
        background: linear-gradient(180deg, #3f7fe6, var(--accent));
        border-color: #3b6fd1;
        color: #061428;
        font-weight: 700;
      }

      .btn-danger {
        background: linear-gradient(180deg, #ff8383, var(--danger));
        border-color: #e26161;
        color: #2a0a0a;
        font-weight: 700;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-bottom: 16px;
      }

      .panel {
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border: 1px solid #262c3b;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 12px;
      }

      .board-wrap {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 16px;
      }

      .board {
        width: 100%;
        max-width: 560px;
        margin: 0 auto;
        aspect-ratio: 1 / 1;
        background: #0c0f17;
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
      }

      .cell {
        border: 1px solid var(--grid);
        position: relative;
        display: grid;
        place-items: center;
        user-select: none;
        -webkit-user-select: none;
        background: transparent;
        transition: background 0.1s ease, color 0.1s ease, box-shadow
          0.15s ease;
      }

      /* Thick 3x3 borders */
      .cell[data-col="2"],
      .cell[data-col="5"] {
        border-right: 2px solid var(--grid-strong);
      }
      .cell[data-col="3"],
      .cell[data-col="6"] {
        border-left: 1px solid var(--grid);
      }
      .cell[data-row="2"],
      .cell[data-row="5"] {
        border-bottom: 2px solid var(--grid-strong);
      }
      .cell[data-row="3"],
      .cell[data-row="6"] {
        border-top: 1px solid var(--grid);
      }

      .num {
        font-size: clamp(20px, 4.2vw, 32px);
        font-weight: 800;
        letter-spacing: 0.6px;
      }

      .notegrid {
        position: absolute;
        inset: 4px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 3px;
        pointer-events: none;
        opacity: 0.85;
      }

      .note {
        font-size: clamp(8px, 1.9vw, 12px);
        color: var(--muted);
        display: grid;
        place-items: center;
      }

      .cell.given {
        background: linear-gradient(180deg, #0d1421, var(--given));
        color: #cfd7ea;
      }

      .cell.selected {
        background: radial-gradient(
            250px 250px at 50% 50%,
            rgba(76, 154, 255, 0.16),
            transparent
          ),
          var(--select);
        box-shadow: inset 0 0 0 1px rgba(76, 154, 255, 0.5);
      }

      .cell.highlight {
        background: var(--highlight);
      }

      .cell.same {
        background: var(--same);
      }

      .cell.conflict {
        background: linear-gradient(
          180deg,
          rgba(255, 68, 68, 0.18),
          rgba(255, 68, 68, 0.06)
        );
      }

      .cell.wrong {
        background: linear-gradient(
          180deg,
          rgba(255, 107, 107, 0.25),
          rgba(255, 107, 107, 0.08)
        );
      }

      .side {
        display: grid;
        gap: 16px;
        align-content: start;
      }

      .keypad {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
      }

      .keypad .digit {
        padding: 12px 0;
        font-size: 18px;
        font-weight: 800;
        border-radius: 12px;
        background: #1f2536;
        border: 1px solid #2d3345;
        position: relative;
      }

      .digit .remain {
        position: absolute;
        right: 8px;
        bottom: 6px;
        font-size: 11px;
        color: var(--muted);
        font-weight: 600;
        opacity: 0.85;
      }

      .toggle.on {
        outline: 2px solid var(--accent-2);
        background: linear-gradient(180deg, #2b3e56, #244159);
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .row > * {
        flex: 1;
      }

      .row .small {
        flex: 0 0 auto;
      }

      .stats {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .badge {
        background: #1f2536;
        border: 1px solid #2d3345;
        border-radius: 10px;
        padding: 6px 10px;
        color: var(--muted);
        font-weight: 700;
      }

      .footer {
        margin-top: 16px;
        text-align: center;
        color: var(--muted);
        font-size: 12px;
      }

      .toast {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 20px;
        padding: 10px 14px;
        border-radius: 12px;
        background: #0b0f19;
        border: 1px solid #20283a;
        box-shadow: var(--shadow);
        font-weight: 700;
        color: var(--text);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-4px);
      }

      @media (max-width: 980px) {
        .board-wrap {
          grid-template-columns: 1fr;
        }
        .right {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="brand">
          <div class="logo">9</div>
          <div class="title">Sudoku</div>
        </div>

        <div class="center">
          <span class="pill" id="timer">⏱ 00:00</span>
          <span class="pill" id="mistakes">Mistakes: 0</span>
        </div>

        <div class="right">
          <select class="select" id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
            <option value="expert">Expert</option>
          </select>
          <button class="btn-primary" id="newGame">New game</button>
          <button id="pauseBtn">Pause</button>
        </div>
      </div>

      <div class="toolbar">
        <div class="panel board-wrap">
          <div class="board" id="board" aria-label="Sudoku board"></div>

          <div class="side">
            <div class="panel">
              <div class="row" style="margin-bottom: 8px">
                <button class="toggle" id="noteMode">Notes</button>
                <button class="toggle" id="autoNotes">Auto-notes</button>
                <button class="toggle" id="showConflicts" class="small">
                  Conflicts
                </button>
                <button class="toggle" id="showMistakes" class="small">
                  Show mistakes
                </button>
              </div>

              <div class="keypad" id="keypad">
                <!-- Digits 1..9 + 0 (clear), laid out dynamically -->
              </div>

              <div class="row" style="margin-top: 8px">
                <button id="undo">Undo</button>
                <button id="redo">Redo</button>
                <button id="erase">Eraser</button>
                <button id="hint">Hint</button>
                <button id="check">Check</button>
                <button id="solve" class="btn-danger">Solve</button>
              </div>
            </div>

            <div class="panel">
              <div style="font-weight: 800; margin-bottom: 8px">
                Controls
              </div>
              <div style="color: var(--muted); font-size: 13px; line-height: 1.6">
                • Click a cell, then use keypad or 1–9 keys. Backspace/Delete
                clears. <br />
                • Toggle Notes (N), Auto-notes (A). <br />
                • Arrow keys to move. Ctrl/Cmd+Z undo, Ctrl/Cmd+Y redo. <br />
                • H for hint. M to toggle mistakes view. C to toggle conflicts.
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">
        Made with care. All in one file. Your progress is saved locally.
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
      // Data model and helpers
      const SIZE = 9;
      const DIGITS = [1, 2, 3, 4, 5, 6, 7, 8, 9];

      const $ = (sel) => document.querySelector(sel);
      const $$ = (sel) => document.querySelectorAll(sel);

      function deepCopy(grid) {
        return grid.map((row) => row.slice());
      }

      function emptyGrid() {
        return Array.from({ length: SIZE }, () =>
          Array.from({ length: SIZE }, () => 0)
        );
      }

      function emptyNotes() {
        return Array.from({ length: SIZE }, () =>
          Array.from({ length: SIZE }, () =>
            Array.from({ length: 10 }, () => false)
          )
        );
      }

      function inBounds(r, c) {
        return r >= 0 && r < SIZE && c >= 0 && c < SIZE;
      }

      function peersOf(r, c) {
        const peers = new Set();
        for (let i = 0; i < SIZE; i++) {
          peers.add(`${r},${i}`);
          peers.add(`${i},${c}`);
        }
        const br = Math.floor(r / 3) * 3;
        const bc = Math.floor(c / 3) * 3;
        for (let rr = 0; rr < 3; rr++) {
          for (let cc = 0; cc < 3; cc++) {
            peers.add(`${br + rr},${bc + cc}`);
          }
        }
        peers.delete(`${r},${c}`);
        return Array.from(peers).map((s) => s.split(",").map((n) => +n));
      }

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function isSafe(grid, r, c, n) {
        for (let i = 0; i < SIZE; i++) {
          if (grid[r][i] === n || grid[i][c] === n) return false;
        }
        const br = Math.floor(r / 3) * 3;
        const bc = Math.floor(c / 3) * 3;
        for (let rr = 0; rr < 3; rr++) {
          for (let cc = 0; cc < 3; cc++) {
            if (grid[br + rr][bc + cc] === n) return false;
          }
        }
        return true;
      }

      function findEmptyCellMRV(grid) {
        let best = null;
        let bestCount = 10;
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] !== 0) continue;
            let count = 0;
            for (let d = 1; d <= 9; d++) {
              if (isSafe(grid, r, c, d)) count++;
            }
            if (count < bestCount) {
              bestCount = count;
              best = [r, c];
              if (count === 1) return best;
            }
          }
        }
        return best;
      }

      function solveCount(grid, limit = 2) {
        const g = deepCopy(grid);
        let solutions = 0;

        function dfs() {
          if (solutions >= limit) return;
          const cell = findEmptyCellMRV(g);
          if (!cell) {
            solutions++;
            return;
          }
          const [r, c] = cell;
          const nums = [];
          for (let d = 1; d <= 9; d++) {
            if (isSafe(g, r, c, d)) nums.push(d);
          }
          for (const n of nums) {
            g[r][c] = n;
            dfs();
            if (solutions >= limit) return;
            g[r][c] = 0;
          }
        }

        dfs();
        return solutions;
      }

      function solveOne(grid) {
        const g = deepCopy(grid);

        function backtrack() {
          const cell = findEmptyCellMRV(g);
          if (!cell) return true;
          const [r, c] = cell;
          const nums = [];
          for (let d = 1; d <= 9; d++) {
            if (isSafe(g, r, c, d)) nums.push(d);
          }
          for (const n of nums) {
            g[r][c] = n;
            if (backtrack()) return true;
            g[r][c] = 0;
          }
          return false;
        }

        return backtrack() ? g : null;
      }

      function generateFullSolution() {
        const grid = emptyGrid();

        function fill() {
          const cell = findEmptyCellMRV(grid);
          if (!cell) return true;
          const [r, c] = cell;
          const nums = shuffle(DIGITS.slice());
          for (const n of nums) {
            if (isSafe(grid, r, c, n)) {
              grid[r][c] = n;
              if (fill()) return true;
              grid[r][c] = 0;
            }
          }
          return false;
        }

        fill();
        return grid;
      }

      function countClues(grid) {
        let cnt = 0;
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] !== 0) cnt++;
          }
        }
        return cnt;
      }

      function pairsSymmetrical() {
        const pairs = [];
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const r2 = SIZE - 1 - r;
            const c2 = SIZE - 1 - c;
            if (r > r2) continue;
            if (r === r2 && c > c2) continue;
            pairs.push([
              [r, c],
              [r2, c2],
            ]);
          }
        }
        return shuffle(pairs);
      }

      function difficultyTarget(diff) {
        switch (diff) {
          case "easy":
            return 40; // clues
          case "medium":
            return 32;
          case "hard":
            return 26;
          case "expert":
            return 22;
          default:
            return 32;
        }
      }

      function makePuzzle(solution, diff = "medium") {
        const targetClues = difficultyTarget(diff);
        const puzzle = deepCopy(solution);
        const pairs = pairsSymmetrical();

        let clues = countClues(puzzle);
        for (const [[r1, c1], [r2, c2]] of pairs) {
          if (clues <= targetClues) break;

          const prev1 = puzzle[r1][c1];
          const prev2 = puzzle[r2][c2];

          // If already empty, skip pair
          if (prev1 === 0 && prev2 === 0) continue;

          // Remove both (if same cell like centre, remove once)
          puzzle[r1][c1] = 0;
          if (!(r1 === r2 && c1 === c2)) puzzle[r2][c2] = 0;

          const solutions = solveCount(puzzle, 2);
          if (solutions !== 1) {
            // revert
            puzzle[r1][c1] = prev1;
            if (!(r1 === r2 && c1 === c2)) puzzle[r2][c2] = prev2;
          } else {
            clues = countClues(puzzle);
          }
        }

        return puzzle;
      }

      function equalsGrid(a, b) {
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (a[r][c] !== b[r][c]) return false;
          }
        }
        return true;
      }

      function computeCandidates(grid) {
        const cand = Array.from({ length: SIZE }, () =>
          Array.from({ length: SIZE }, () => [])
        );
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] !== 0) continue;
            for (let d = 1; d <= 9; d++) {
              if (isSafe(grid, r, c, d)) cand[r][c].push(d);
            }
          }
        }
        return cand;
      }

      function nakedSingle(grid) {
        const cand = computeCandidates(grid);
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (grid[r][c] === 0 && cand[r][c].length === 1) {
              return { r, c, n: cand[r][c][0], type: "Naked single" };
            }
          }
        }
        return null;
      }

      function hiddenSingle(grid) {
        const cand = computeCandidates(grid);

        // Rows
        for (let r = 0; r < SIZE; r++) {
          for (let d = 1; d <= 9; d++) {
            const spots = [];
            for (let c = 0; c < SIZE; c++) {
              if (grid[r][c] === 0 && cand[r][c].includes(d)) {
                spots.push([r, c]);
              }
            }
            if (spots.length === 1) {
              const [rr, cc] = spots[0];
              return { r: rr, c: cc, n: d, type: "Hidden single (row)" };
            }
          }
        }

        // Cols
        for (let c = 0; c < SIZE; c++) {
          for (let d = 1; d <= 9; d++) {
            const spots = [];
            for (let r = 0; r < SIZE; r++) {
              if (grid[r][c] === 0 && cand[r][c].includes(d)) {
                spots.push([r, c]);
              }
            }
            if (spots.length === 1) {
              const [rr, cc] = spots[0];
              return { r: rr, c: cc, n: d, type: "Hidden single (col)" };
            }
          }
        }

        // Boxes
        for (let br = 0; br < 3; br++) {
          for (let bc = 0; bc < 3; bc++) {
            for (let d = 1; d <= 9; d++) {
              const spots = [];
              for (let rr = 0; rr < 3; rr++) {
                for (let cc = 0; cc < 3; cc++) {
                  const r = br * 3 + rr;
                  const c = bc * 3 + cc;
                  if (grid[r][c] === 0 && cand[r][c].includes(d)) {
                    spots.push([r, c]);
                  }
                }
              }
              if (spots.length === 1) {
                const [rr, cc] = spots[0];
                return {
                  r: rr,
                  c: cc,
                  n: d,
                  type: "Hidden single (box)",
                };
              }
            }
          }
        }

        return null;
      }

      // App state
      const state = {
        puzzle: emptyGrid(),
        solution: emptyGrid(),
        grid: emptyGrid(),
        notes: emptyNotes(),
        selected: null, // {r,c}
        settings: {
          noteMode: false,
          autoNotes: false,
          showConflicts: true,
          showMistakes: false,
        },
        difficulty: "medium",
        timer: {
          start: null,
          elapsed: 0,
          paused: false,
          interval: null,
        },
        undo: [],
        redo: [],
        mistakes: 0,
      };

      // DOM build
      const boardEl = $("#board");
      const keypadEl = $("#keypad");
      const timerEl = $("#timer");
      const mistakesEl = $("#mistakes");
      const toastEl = $("#toast");

      function showToast(msg) {
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        setTimeout(() => toastEl.classList.remove("show"), 1600);
      }

      function buildBoard() {
        boardEl.innerHTML = "";
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.dataset.row = r;
            cell.dataset.col = c;
            cell.setAttribute("role", "button");
            cell.setAttribute("tabindex", "0");
            cell.setAttribute(
              "aria-label",
              `Cell r${r + 1} c${c + 1}`
            );

            const num = document.createElement("div");
            num.className = "num";
            cell.appendChild(num);

            const noteGrid = document.createElement("div");
            noteGrid.className = "notegrid";
            for (let d = 1; d <= 9; d++) {
              const n = document.createElement("div");
              n.className = "note";
              n.textContent = d;
              n.dataset.d = d;
              noteGrid.appendChild(n);
            }
            cell.appendChild(noteGrid);

            cell.addEventListener("click", () => onCellClick(r, c));
            cell.addEventListener("keydown", (e) => onCellKey(e, r, c));

            boardEl.appendChild(cell);
          }
        }
      }

      function buildKeypad() {
        keypadEl.innerHTML = "";
        for (let d = 1; d <= 9; d++) {
          const btn = document.createElement("button");
          btn.className = "digit";
          btn.textContent = d;
          btn.dataset.d = d;
          const rem = document.createElement("span");
          rem.className = "remain";
          rem.textContent = "9";
          btn.appendChild(rem);
          btn.addEventListener("click", () => onDigit(d));
          keypadEl.appendChild(btn);
        }
        // Clear / 0
        const clr = document.createElement("button");
        clr.className = "digit";
        clr.textContent = "⌫";
        clr.title = "Clear (Backspace/Delete)";
        clr.addEventListener("click", () => onDigit(0));
        keypadEl.appendChild(clr);
      }

      // Rendering
      function render() {
        // Cells
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const idx = r * SIZE + c;
            const cell = boardEl.children[idx];
            const numEl = cell.querySelector(".num");
            const noteEls = cell.querySelectorAll(".note");

            const isGiven = state.puzzle[r][c] !== 0;
            const val = state.grid[r][c];

            cell.classList.toggle("given", isGiven);
            cell.classList.toggle(
              "selected",
              state.selected &&
                state.selected.r === r &&
                state.selected.c === c
            );

            // row/col/box highlights
            const sel = state.selected;
            const sameRow = sel && sel.r === r;
            const sameCol = sel && sel.c === c;
            const sameBox =
              sel &&
              Math.floor(sel.r / 3) === Math.floor(r / 3) &&
              Math.floor(sel.c / 3) === Math.floor(c / 3);
            const highlight =
              (sameRow || sameCol || sameBox) && !(sel && sel.r === r && sel.c === c);

            cell.classList.toggle("highlight", !!highlight);

            // same number highlight
            let sameNum = false;
            if (sel) {
              const selVal = state.grid[sel.r][sel.c];
              if (selVal !== 0 && val === selVal) sameNum = true;
            }
            cell.classList.toggle("same", sameNum);

            // conflicts
            const conflict = hasConflict(state.grid, r, c);
            cell.classList.toggle(
              "conflict",
              conflict && state.settings.showConflicts && val !== 0
            );

            // mistakes (compare to solution)
            const wrong =
              val !== 0 &&
              state.solution &&
              state.solution[r][c] !== val &&
              !isGiven;
            cell.classList.toggle(
              "wrong",
              wrong && state.settings.showMistakes
            );

            // number or notes
            if (val !== 0) {
              numEl.textContent = val;
              numEl.style.visibility = "visible";
              cell.querySelector(".notegrid").style.visibility = "hidden";
            } else {
              numEl.textContent = "";
              numEl.style.visibility = "hidden";
              const notes = state.notes[r][c];
              cell.querySelector(".notegrid").style.visibility = "visible";
              noteEls.forEach((n) => {
                const d = +n.dataset.d;
                n.style.visibility = notes[d] ? "visible" : "hidden";
              });
            }
          }
        }

        // keypad remaining counts
        const counts = digitCounts(state.grid);
        const kbtns = keypadEl.querySelectorAll(".digit");
        kbtns.forEach((btn) => {
          const d = +btn.dataset.d;
          const rem = btn.querySelector(".remain");
          if (!rem) return;
          const used = counts[d] || 0;
          rem.textContent = String(9 - used);
          btn.style.opacity = used >= 9 ? 0.35 : 1;
        });

        // toggles
        $("#noteMode").classList.toggle("on", state.settings.noteMode);
        $("#autoNotes").classList.toggle("on", state.settings.autoNotes);
        $("#showConflicts").classList.toggle(
          "on",
          state.settings.showConflicts
        );
        $("#showMistakes").classList.toggle("on", state.settings.showMistakes);

        // timer + mistakes
        mistakesEl.textContent = `Mistakes: ${state.mistakes}`;
      }

      function hasConflict(grid, r, c) {
        const v = grid[r][c];
        if (v === 0) return false;
        // same row/col/box duplicates
        for (let i = 0; i < SIZE; i++) {
          if (i !== c && grid[r][i] === v) return true;
          if (i !== r && grid[i][c] === v) return true;
        }
        const br = Math.floor(r / 3) * 3;
        const bc = Math.floor(c / 3) * 3;
        for (let rr = 0; rr < 3; rr++) {
          for (let cc = 0; cc < 3; cc++) {
            const R = br + rr;
            const C = bc + cc;
            if ((R !== r || C !== c) && grid[R][C] === v) return true;
          }
        }
        return false;
      }

      function digitCounts(grid) {
        const map = {};
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            const v = grid[r][c];
            if (v) map[v] = (map[v] || 0) + 1;
          }
        }
        return map;
      }

      // Notes helpers
      function fillAutoNotes() {
        const cand = computeCandidates(state.grid);
        for (let r = 0; r < SIZE; r++) {
          for (let c = 0; c < SIZE; c++) {
            if (state.grid[r][c] !== 0) {
              state.notes[r][c] = Array.from({ length: 10 }, () => false);
              continue;
            }
            const arr = Array.from({ length: 10 }, () => false);
            for (const d of cand[r][c]) arr[d] = true;
            state.notes[r][c] = arr;
          }
        }
      }

      function clearPeerNotes(r, c, n) {
        for (const [rr, cc] of peersOf(r, c)) {
          if (state.grid[rr][cc] === 0) {
            state.notes[rr][cc][n] = false;
          }
        }
      }

      // Selection and input
      function onCellClick(r, c) {
        if (state.selected && state.selected.r === r && state.selected.c === c) {
          // second click toggles note mode quick?
          // keep as select only
        } else {
          state.selected = { r, c };
          render();
        }
      }

      function onCellKey(e, r, c) {
        const key = e.key;
        if (/^[1-9]$/.test(key)) {
          onDigit(+key);
          e.preventDefault();
        } else if (key === "Backspace" || key === "Delete" || key === "0") {
          onDigit(0);
          e.preventDefault();
        } else if (key === "ArrowUp") {
          moveSel(-1, 0);
          e.preventDefault();
        } else if (key === "ArrowDown") {
          moveSel(1, 0);
          e.preventDefault();
        } else if (key === "ArrowLeft") {
          moveSel(0, -1);
          e.preventDefault();
        } else if (key === "ArrowRight") {
          moveSel(0, 1);
          e.preventDefault();
        } else if (key.toLowerCase() === "n") {
          toggleNoteMode();
        } else if (key.toLowerCase() === "a") {
          toggleAutoNotes();
        } else if (key.toLowerCase() === "h") {
          onHint();
        } else if (key.toLowerCase() === "m") {
          toggleShowMistakes();
        } else if (key.toLowerCase() === "c") {
          toggleShowConflicts();
        }
      }

      function moveSel(dr, dc) {
        if (!state.selected) {
          state.selected = { r: 0, c: 0 };
          render();
          return;
        }
        let r = state.selected.r + dr;
        let c = state.selected.c + dc;
        r = Math.max(0, Math.min(8, r));
        c = Math.max(0, Math.min(8, c));
        state.selected = { r, c };
        // focus corresponding element for screen readers
        const idx = r * SIZE + c;
        boardEl.children[idx].focus();
        render();
      }

      function onDigit(d) {
        if (!state.selected) {
          showToast("Select a cell first");
          return;
        }
        const { r, c } = state.selected;
        if (state.puzzle[r][c] !== 0) {
          showToast("That cell is fixed");
          return;
        }

        if (state.settings.noteMode && state.grid[r][c] === 0) {
          // toggle note
          if (d === 0) {
            // clear all notes
            pushUndo({
              t: "notesClear",
              r,
              c,
              prev: state.notes[r][c].slice(),
            });
            state.notes[r][c] = Array.from({ length: 10 }, () => false);
          } else {
            const prev = state.notes[r][c].slice();
            state.notes[r][c][d] = !state.notes[r][c][d];
            pushUndo({
              t: "note",
              r,
              c,
              d,
              prev,
            });
          }
          render();
          saveState();
          return;
        }

        const prevVal = state.grid[r][c];
        const prevNotes = state.notes[r][c].slice();

        if (d === prevVal) return;

        pushUndo({
          t: "set",
          r,
          c,
          prev: prevVal,
          next: d,
          prevNotes,
        });

        state.grid[r][c] = d;
        if (d === 0) {
          // cleared: optional re-add auto-notes if enabled
          if (state.settings.autoNotes) fillAutoNotes();
        } else {
          // entering a digit
          state.notes[r][c] = Array.from({ length: 10 }, () => false);
          if (state.settings.autoNotes) clearPeerNotes(r, c, d);
          if (state.settings.showMistakes && state.solution) {
            if (d !== state.solution[r][c]) {
              state.mistakes++;
              showToast("Mistake recorded");
            }
          }
        }

        render();
        saveState();

        // Check solved
        if (equalsGrid(state.grid, state.solution)) {
          stopTimer();
          showToast("Solved! Well done");
        }
      }

      function pushUndo(op) {
        state.undo.push(op);
        state.redo.length = 0;
      }

      function onUndo() {
        const op = state.undo.pop();
        if (!op) return;
        state.redo.push(op);
        applyInverse(op);
        render();
        saveState();
      }

      function onRedo() {
        const op = state.redo.pop();
        if (!op) return;
        state.undo.push(op);
        apply(op);
        render();
        saveState();
      }

      function apply(op) {
        if (op.t === "set") {
          state.grid[op.r][op.c] = op.next;
          if (op.next !== 0) {
            state.notes[op.r][op.c] = Array.from(
              { length: 10 },
              () => false
            );
          } else {
            state.notes[op.r][op.c] = op.prevNotes.slice();
          }
        } else if (op.t === "note") {
          state.notes[op.r][op.c] = op.prev.slice();
          state.notes[op.r][op.c][op.d] = !op.prev[op.d];
        } else if (op.t === "notesClear") {
          state.notes[op.r][op.c] = Array.from(
            { length: 10 },
            () => false
          );
        }
      }

      function applyInverse(op) {
        if (op.t === "set") {
          state.grid[op.r][op.c] = op.prev;
          state.notes[op.r][op.c] = op.prevNotes.slice();
        } else if (op.t === "note") {
          state.notes[op.r][op.c] = op.prev.slice();
        } else if (op.t === "notesClear") {
          state.notes[op.r][op.c] = op.prev.slice();
        }
      }

      // Buttons and toggles
      function toggleNoteMode() {
        state.settings.noteMode = !state.settings.noteMode;
        render();
        saveState();
      }

      function toggleAutoNotes() {
        state.settings.autoNotes = !state.settings.autoNotes;
        if (state.settings.autoNotes) fillAutoNotes();
        render();
        saveState();
      }

      function toggleShowConflicts() {
        state.settings.showConflicts = !state.settings.showConflicts;
        render();
        saveState();
      }

      function toggleShowMistakes() {
        state.settings.showMistakes = !state.settings.showMistakes;
        render();
        saveState();
      }

      function onErase() {
        if (!state.selected) return;
        onDigit(0);
      }

      function onCheck() {
        // Toggle mistakes view briefly if off
        if (!state.settings.showMistakes) {
          state.settings.showMistakes = true;
          render();
          setTimeout(() => {
            state.settings.showMistakes = false;
            render();
          }, 1300);
          showToast("Highlighted incorrect entries");
        } else {
          render();
          showToast("Mistakes are already visible");
        }
      }

      function onSolve() {
        if (!state.solution) return;
        pushUndo({
          t: "bulk",
          prevGrid: deepCopy(state.grid),
          prevNotes: JSON.parse(JSON.stringify(state.notes)),
        });
        state.grid = deepCopy(state.solution);
        state.notes = emptyNotes();
        render();
        stopTimer();
        showToast("Solved for you");
        saveState();
      }

      function onHint() {
        const g = state.grid;
        const step =
          nakedSingle(g) ||
          hiddenSingle(g) ||
          null;

        if (!step) {
          showToast("No simple hints available");
          return;
        }

        const { r, c, n, type } = step;
        // Select and fill number
        state.selected = { r, c };
        onDigit(n);
        showToast(`${type}: r${r + 1} c${c + 1} is ${n}`);
      }

      // Timer
      function startTimer(reset = true) {
        if (reset) {
          state.timer.elapsed = 0;
          state.timer.start = Date.now();
        } else if (!state.timer.start) {
          state.timer.start = Date.now() - state.timer.elapsed;
        }
        state.timer.paused = false;
        clearInterval(state.timer.interval);
        state.timer.interval = setInterval(updateTimer, 250);
        updateTimer();
      }

      function stopTimer() {
        clearInterval(state.timer.interval);
        state.timer.interval = null;
        updateTimer();
      }

      function pauseTimer() {
        if (state.timer.paused) return;
        state.timer.paused = true;
        state.timer.elapsed = Date.now() - state.timer.start;
        stopTimer();
        $("#pauseBtn").textContent = "Resume";
      }

      function resumeTimer() {
        if (!state.timer.paused) return;
        state.timer.paused = false;
        state.timer.start = Date.now() - state.timer.elapsed;
        startTimer(false);
        $("#pauseBtn").textContent = "Pause";
      }

      function updateTimer() {
        let ms = state.timer.elapsed;
        if (!state.timer.paused && state.timer.start) {
          ms = Date.now() - state.timer.start;
        }
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const ss = String(s % 60).padStart(2, "0");
        const mm = String(m).padStart(2, "0");
        timerEl.textContent = `⏱ ${mm}:${ss}`;
      }

      // Save / Load
      const STORAGE_KEY = "sudoku-state-v2";

      function saveState() {
        const data = {
          puzzle: state.puzzle,
          solution: state.solution,
          grid: state.grid,
          notes: state.notes,
          settings: state.settings,
          difficulty: state.difficulty,
          timer: {
            start: state.timer.start,
            elapsed: state.timer.elapsed,
            paused: state.timer.paused,
          },
          mistakes: state.mistakes,
        };
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        } catch {}
      }

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return false;
          const data = JSON.parse(raw);
          state.puzzle = data.puzzle || emptyGrid();
          state.solution = data.solution || emptyGrid();
          state.grid = data.grid || emptyGrid();
          state.notes = data.notes || emptyNotes();
          state.settings = Object.assign(
            {},
            state.settings,
            data.settings || {}
          );
          state.difficulty = data.difficulty || "medium";
          const t = data.timer || {};
          state.timer.start = t.start;
          state.timer.elapsed = t.elapsed || 0;
          state.timer.paused = !!t.paused;
          state.mistakes = data.mistakes || 0;

          $("#difficulty").value = state.difficulty;

          // Resume/pause timer
          if (equalsGrid(state.grid, state.solution)) {
            stopTimer();
          } else if (state.timer.paused) {
            updateTimer();
            $("#pauseBtn").textContent = "Resume";
          } else {
            startTimer(false);
            $("#pauseBtn").textContent = "Pause";
          }

          return true;
        } catch {
          return false;
        }
      }

      // New game
      async function newGame(diff) {
        // Busy UI
        $("#newGame").disabled = true;
        $("#newGame").textContent = "Generating…";
        try {
          await new Promise((r) => setTimeout(r, 20));

          const solution = generateFullSolution();
          const puzzle = makePuzzle(solution, diff);

          state.puzzle = deepCopy(puzzle);
          state.solution = deepCopy(solution);
          state.grid = deepCopy(puzzle);
          state.notes = emptyNotes();
          state.selected = null;
          state.settings.noteMode = false;
          state.mistakes = 0;
          state.undo.length = 0;
          state.redo.length = 0;
          state.difficulty = diff;

          if (state.settings.autoNotes) fillAutoNotes();

          $("#difficulty").value = diff;

          startTimer(true);
          $("#pauseBtn").textContent = "Pause";

          render();
          saveState();
        } finally {
          $("#newGame").disabled = false;
          $("#newGame").textContent = "New game";
        }
      }

      // Events
      $("#newGame").addEventListener("click", () => {
        const diff = $("#difficulty").value;
        newGame(diff);
      });

      $("#pauseBtn").addEventListener("click", () => {
        if (state.timer.paused) {
          resumeTimer();
        } else {
          pauseTimer();
        }
      });

      $("#difficulty").addEventListener("change", (e) => {
        state.difficulty = e.target.value;
        saveState();
      });

      $("#noteMode").addEventListener("click", toggleNoteMode);
      $("#autoNotes").addEventListener("click", toggleAutoNotes);
      $("#showConflicts").addEventListener("click", toggleShowConflicts);
      $("#showMistakes").addEventListener("click", toggleShowMistakes);

      $("#undo").addEventListener("click", onUndo);
      $("#redo").addEventListener("click", onRedo);
      $("#erase").addEventListener("click", onErase);
      $("#hint").addEventListener("click", onHint);
      $("#check").addEventListener("click", onCheck);
      $("#solve").addEventListener("click", onSolve);

      document.addEventListener("keydown", (e) => {
        const ctrl = e.ctrlKey || e.metaKey;
        if (ctrl && e.key.toLowerCase() === "z") {
          onUndo();
          e.preventDefault();
        } else if (ctrl && e.key.toLowerCase() === "y") {
          onRedo();
          e.preventDefault();
        }
      });

      function onDigitKey(e) {
        if (!state.selected) return;
        if (/^[1-9]$/.test(e.key)) {
          onDigit(+e.key);
        } else if (e.key === "Backspace" || e.key === "Delete" || e.key === "0") {
          onDigit(0);
        }
      }

      document.addEventListener("keydown", onDigitKey);

      function onDigit(d) {
        // delegate to earlier function defined already
        // To avoid shadowing, the earlier onDigit is hoisted.
        // This wrapper is only to satisfy Prettier line width.
        return window.__onDigit(d);
      }

      // Rebind the actual onDigit to global to keep call sites intact
      window.__onDigit = function (d) {
        // actual logic lives here; copied from earlier onDigit def
        if (!state.selected) {
          showToast("Select a cell first");
          return;
        }
        const { r, c } = state.selected;
        if (state.puzzle[r][c] !== 0) {
          showToast("That cell is fixed");
          return;
        }

        if (state.settings.noteMode && state.grid[r][c] === 0) {
          if (d === 0) {
            pushUndo({
              t: "notesClear",
              r,
              c,
              prev: state.notes[r][c].slice(),
            });
            state.notes[r][c] = Array.from({ length: 10 }, () => false);
          } else {
            const prev = state.notes[r][c].slice();
            state.notes[r][c][d] = !state.notes[r][c][d];
            pushUndo({
              t: "note",
              r,
              c,
              d,
              prev,
            });
          }
          render();
          saveState();
          return;
        }

        const prevVal = state.grid[r][c];
        const prevNotes = state.notes[r][c].slice();
        if (d === prevVal) return;

        pushUndo({
          t: "set",
          r,
          c,
          prev: prevVal,
          next: d,
          prevNotes,
        });

        state.grid[r][c] = d;
        if (d === 0) {
          if (state.settings.autoNotes) fillAutoNotes();
        } else {
          state.notes[r][c] = Array.from({ length: 10 }, () => false);
          if (state.settings.autoNotes) clearPeerNotes(r, c, d);
          if (state.settings.showMistakes && state.solution) {
            if (d !== state.solution[r][c]) {
              state.mistakes++;
              showToast("Mistake recorded");
            }
          }
        }
        render();
        saveState();

        if (equalsGrid(state.grid, state.solution)) {
          stopTimer();
          showToast("Solved! Well done");
        }
      };

      // Init
      buildBoard();
      buildKeypad();

      if (!loadState()) {
        // first visit
        newGame("medium");
      } else {
        render();
      }
    </script>
  </body>
</html>
